<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/11/12/JVM_object_memory_allocate/"/>
    <url>/2024/11/12/JVM_object_memory_allocate/</url>
    
    <content type="html"><![CDATA[<h1 id="1-对象的实例化"><a href="#1-对象的实例化" class="headerlink" title="1.对象的实例化"></a>1.对象的实例化</h1><h2 id="1-1-创建对象的方式"><a href="#1-1-创建对象的方式" class="headerlink" title="1.1 创建对象的方式"></a>1.1 创建对象的方式</h2><ol><li>使用 new 关键字</li><li>使用 clone() 方法，不调用构造器，但是类必须实现 Cloneable() 接口，实现 clone() ，默认是浅拷贝</li><li>使用 Class 的 newInstance() 方法：反射的方式，只能是空参的构造器，并且权限是 public</li><li>使用 Constructor 的 newInstance() 方法：反射的方式，可以调用空参、带参的构造函数，权限没有要求，使用更加广泛</li><li>反序列化：从文件、网络、数据库中获得一个二进制数据流，反序列化为对线</li><li>使用第三方库</li></ol><h2 id="1-2-对象创建的步骤"><a href="#1-2-对象创建的步骤" class="headerlink" title="1.2 对象创建的步骤"></a>1.2 对象创建的步骤</h2><h3 id="从字节码角度看对象创建的过程"><a href="#从字节码角度看对象创建的过程" class="headerlink" title="从字节码角度看对象创建的过程"></a>从字节码角度看对象创建的过程</h3><blockquote><p>C10K的问题我这 1 bit 的脑子不够用了，此处先省略2000字</p></blockquote><h3 id="从执行步骤角度分析"><a href="#从执行步骤角度分析" class="headerlink" title="从执行步骤角度分析"></a>从执行步骤角度分析</h3><ol><li>判断对象对应的类是否加载、链接、初始化。如果没有，在双亲委派机制下使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件，如果没找到该文件，则抛出 ClassNotFoundExecption 异常，如果找到，则进行类加载，并生成对应的 Class 类的对象</li><li><code>&lt;font color=&quot;red&quot;&gt;</code>为对象分配内存：<code>&lt;/font&gt;</code><br>两种方式：<ul><li>指针碰撞：在内存规整的情况下，由一个指针指向内存中已使用和未使用的中间位置(说人话就是已使用的内存和未使用的内存分别在两边，中间有一条河作为分界线，这个河就是分界指针)，每次在需要分配内存的时候，将指针向未使用空间移动要分配的大小。如果虚拟机使用的是 Serial、ParNew 这种基于压缩算法的，虚拟机栈采用这种分配方式分配内存。</li><li>空闲列表：如果内存不是规整的，则使用空闲列表法进行对象空间分配。这个方法的意思是虚拟机维护了一个列表，记录着哪些内存是可用的，在分配的时候直接查找列表从列表中查找一块足够大的空间分配给对象实例，并更行列表内容。这种分配方式称为“空闲列表（Free List）”。</li></ul></li><li>处理并发安全问题：在创建对象的时候有可能会出现并发创建的问题，这个时候虚拟机需要保证线程安全性，虚拟机采用了两种方式实现：<ul><li>CAS（Compare And Swap）：失败重试、区域加锁：保证指针更新操作的原子性</li><li>TLAB 把内存分配的动作按照线程划分在不同的空间职中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer）虚拟机是否使用TLAB，可以通过-XX:+&#x2F;-UseTLAB参数来设定。</li></ul></li><li>初始化分配到的空间：内存分配结束，虚拟机将分配到的内存空间都初始化为零（不包含对象头）。这一步保证了对象的实例字段在 Java 代码中可以不用赋值就可以直接使用，程序能访问到这些数据类型兑现的字段的零值。</li><li>设置对象的对象头：将对象的所属类（即类的元数据信息）、对象的HashCode和对象的GC信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于JVM实现</li><li>执行 init 方法进行初始化：在Java程序的视角看来，初始化才正式开始。初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。<br>因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来</li></ol><blockquote><p>至此对象的实例化才算完成</p></blockquote><h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2><p>一个对象主要是有对象头和实力数据组成，还包括一个可能存在的对齐填充。接下来就让我们一起了解一下他们   ———-&gt;</p><h3 id="2-1-对象头："><a href="#2-1-对象头：" class="headerlink" title="2.1 对象头："></a>2.1 对象头：</h3><p>主要包括两部分：</p><ul><li><p>一个是对象自身的 <code>&lt;font color=&quot;red&quot;&gt;</code>运行时元数据（Mark Word）<code>&lt;/font&gt;</code>：</p><ul><li>哈希值（hashcode）：对象在堆空间中都有一个首地址值，栈空间的引用根据这个地址指向堆中的对象，这就是哈希值起的作用</li><li>GC 分代年龄：对象首先是在 Eden 中创建的，在经过多次 GC 后，如果没有被进行回收，就会在 survivor 中来回移动，其对应的年龄计数器就会发生变化，达到阈值后就会进入老年代</li><li>锁状态标志，在同步中判断该对象是否被占用</li><li>线程持有的锁</li><li>线程偏向 ID</li><li>偏向时间戳</li></ul></li><li><p>另一个就是类型指针，指向元数据区的类元数据 InstanceClass，确定该对象所属的类型</p></li><li><p>此外如果对象是一个数组，对象头中还必须有一块用于记录数组的长度的数据。因为正常对象元数据就知道对象的确切大小，所以数组必须得知道长度</p></li></ul><h3 id="2-2-实例数据"><a href="#2-2-实例数据" class="headerlink" title="2.2 实例数据"></a>2.2 实例数据</h3><p>作用：它是真正保存对象有效信息的，包括代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）<br><code>&lt;br&gt;</code><br>这里需要遵守一些规则：</p><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前（因为父类的加载是优先于子类加载的）</li><li>如果CompactFields参数为true(默认为true)：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="2-3-对齐填充"><a href="#2-3-对齐填充" class="headerlink" title="2.3 对齐填充"></a>2.3 对齐填充</h3><p>不是必须的，也没有特别含义，仅仅起到占位的作用</p><h2 id="3-对象的访问定位"><a href="#3-对象的访问定位" class="headerlink" title="3. 对象的访问定位"></a>3. 对象的访问定位</h2><p>创建对象的目的就是为了使用它。定位，通过 栈上 refence 访问</p><p>主流的对象访问方式有两种：</p><ul><li>使用句柄访问</li><li>使用直接指针访问</li></ul><blockquote><p>请读者注意，此处本人了解甚微，深入的内容请大家自行查阅补充</p></blockquote><h3 id="3-1-使用句柄访问："><a href="#3-1-使用句柄访问：" class="headerlink" title="3.1 使用句柄访问："></a>3.1 使用句柄访问：</h3><ul><li>实现：堆需要划分出一块内存来做句柄池，reference中存储对象的句柄池地址，句柄中包含对象实例与类型数据各自具体的地址信息。</li><li>好处：reference中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针，reference本身不需要被修改。</li></ul><h3 id="3-2-使用直接指针访问"><a href="#3-2-使用直接指针访问" class="headerlink" title="3.2 使用直接指针访问"></a>3.2 使用直接指针访问</h3><ul><li>实现：reference中存储的就是对象的地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。</li><li>好处：速度更快，java中对象访问频繁，每次访问都节省了一次指针定位的时间开销</li></ul><p><strong>而 HotSpot这里主要使用第2种方式：直接指针访问</strong></p><p>JVM可以通过对象引用准确定位到Java堆区中的instanceOopDesc对象，这样既可成功访问到对象的实例信息，当需要访问目标对象的具体类型时，JVM则会通过存储在instanceOopDesc中的元数据指针定位到存储在方法区中的instanceKlass对象上</p><p>至此内存布局篇结束，希望广大读者发现问题及时纠正一下！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>about</title>
    <link href="/2024/10/27/about/"/>
    <url>/2024/10/27/about/</url>
    
    <content type="html"><![CDATA[<h1 id="我使用了什么语言"><a href="#我使用了什么语言" class="headerlink" title="我使用了什么语言"></a>我使用了什么语言</h1><ul><li>HTML</li><li>Java</li><li>Python</li><li>SQL</li><li>Mark</li></ul><hr><h1 id="我使用的开发工具"><a href="#我使用的开发工具" class="headerlink" title="我使用的开发工具"></a>我使用的开发工具</h1><ul><li>IDEA</li><li>Github</li><li>CSDN “CSDN” : 一岁半大魔王</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
